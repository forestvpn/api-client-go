/*
ForestVPN API

ForestVPN defeats content restrictions and censorship to deliver unlimited access to video, music, social media, and more, from anywhere in the world. 

API version: 2.0
Contact: support@forestvpn.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package forestvpn_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type DeviceApi interface {

	/*
	CreateDevice Create new device

	Create new device


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDeviceRequest
	*/
	CreateDevice(ctx context.Context) ApiCreateDeviceRequest

	// CreateDeviceExecute executes the request
	//  @return Device
	CreateDeviceExecute(r ApiCreateDeviceRequest) (*Device, *http.Response, error)

	/*
	CreateDevicePortForwarding Create new device port forwarding

	Create new device port forwarding


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiCreateDevicePortForwardingRequest
	*/
	CreateDevicePortForwarding(ctx context.Context, deviceID string) ApiCreateDevicePortForwardingRequest

	// CreateDevicePortForwardingExecute executes the request
	//  @return PortForwarding
	CreateDevicePortForwardingExecute(r ApiCreateDevicePortForwardingRequest) (*PortForwarding, *http.Response, error)

	/*
	DeleteDevice Delete Device

	Delete device by id


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiDeleteDeviceRequest
	*/
	DeleteDevice(ctx context.Context, deviceID string) ApiDeleteDeviceRequest

	// DeleteDeviceExecute executes the request
	DeleteDeviceExecute(r ApiDeleteDeviceRequest) (*http.Response, error)

	/*
	DeleteDevicePortForwarding Delete Device's Port Forwarding

	Delete device's port forwarding by id


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@param portForwardingID
	@return ApiDeleteDevicePortForwardingRequest
	*/
	DeleteDevicePortForwarding(ctx context.Context, deviceID string, portForwardingID string) ApiDeleteDevicePortForwardingRequest

	// DeleteDevicePortForwardingExecute executes the request
	DeleteDevicePortForwardingExecute(r ApiDeleteDevicePortForwardingRequest) (*http.Response, error)

	/*
	GetDevice Device Info

	Retrieve device info


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiGetDeviceRequest
	*/
	GetDevice(ctx context.Context, deviceID string) ApiGetDeviceRequest

	// GetDeviceExecute executes the request
	//  @return Device
	GetDeviceExecute(r ApiGetDeviceRequest) (*Device, *http.Response, error)

	/*
	GetDeviceStats Device's stats detail

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@param statsID
	@return ApiGetDeviceStatsRequest
	*/
	GetDeviceStats(ctx context.Context, deviceID string, statsID string) ApiGetDeviceStatsRequest

	// GetDeviceStatsExecute executes the request
	//  @return DeviceStats
	GetDeviceStatsExecute(r ApiGetDeviceStatsRequest) (*DeviceStats, *http.Response, error)

	/*
	GetDeviceWireGuard Device's wireguard profile detail

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@param wireGuardID
	@return ApiGetDeviceWireGuardRequest
	*/
	GetDeviceWireGuard(ctx context.Context, deviceID string, wireGuardID string) ApiGetDeviceWireGuardRequest

	// GetDeviceWireGuardExecute executes the request
	//  @return WireGuard
	GetDeviceWireGuardExecute(r ApiGetDeviceWireGuardRequest) (*WireGuard, *http.Response, error)

	/*
	ListDeviceBindings Device bindings

	Each device has bindings to specific servers. This methods returns hostnames where this device binded
in a particular time.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiListDeviceBindingsRequest
	*/
	ListDeviceBindings(ctx context.Context, deviceID string) ApiListDeviceBindingsRequest

	// ListDeviceBindingsExecute executes the request
	//  @return []string
	ListDeviceBindingsExecute(r ApiListDeviceBindingsRequest) ([]string, *http.Response, error)

	/*
	ListDeviceConnectionModes Device connection modes

	This methods returns list of connection modes are availbale for current device.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiListDeviceConnectionModesRequest
	*/
	ListDeviceConnectionModes(ctx context.Context, deviceID string) ApiListDeviceConnectionModesRequest

	// ListDeviceConnectionModesExecute executes the request
	//  @return []ConnectionMode
	ListDeviceConnectionModesExecute(r ApiListDeviceConnectionModesRequest) ([]ConnectionMode, *http.Response, error)

	/*
	ListDeviceDetailStats Device's detail stats list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiListDeviceDetailStatsRequest
	*/
	ListDeviceDetailStats(ctx context.Context, deviceID string) ApiListDeviceDetailStatsRequest

	// ListDeviceDetailStatsExecute executes the request
	//  @return []DeviceStats
	ListDeviceDetailStatsExecute(r ApiListDeviceDetailStatsRequest) ([]DeviceStats, *http.Response, error)

	/*
	ListDevicePortForwardings Device Port Forwarding List

	Retrieve device's port forwarding lis


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiListDevicePortForwardingsRequest
	*/
	ListDevicePortForwardings(ctx context.Context, deviceID string) ApiListDevicePortForwardingsRequest

	// ListDevicePortForwardingsExecute executes the request
	//  @return []PortForwarding
	ListDevicePortForwardingsExecute(r ApiListDevicePortForwardingsRequest) ([]PortForwarding, *http.Response, error)

	/*
	ListDeviceStats Device's stats list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiListDeviceStatsRequest
	*/
	ListDeviceStats(ctx context.Context, deviceID string) ApiListDeviceStatsRequest

	// ListDeviceStatsExecute executes the request
	//  @return []DeviceStats
	ListDeviceStatsExecute(r ApiListDeviceStatsRequest) ([]DeviceStats, *http.Response, error)

	/*
	ListDeviceWireGuardPeers Device's wireguard peers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@param wireGuardID
	@return ApiListDeviceWireGuardPeersRequest
	*/
	ListDeviceWireGuardPeers(ctx context.Context, deviceID string, wireGuardID string) ApiListDeviceWireGuardPeersRequest

	// ListDeviceWireGuardPeersExecute executes the request
	//  @return []WireGuardPeer
	ListDeviceWireGuardPeersExecute(r ApiListDeviceWireGuardPeersRequest) ([]WireGuardPeer, *http.Response, error)

	/*
	ListDeviceWireGuards Device's wireguard profiles list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiListDeviceWireGuardsRequest
	*/
	ListDeviceWireGuards(ctx context.Context, deviceID string) ApiListDeviceWireGuardsRequest

	// ListDeviceWireGuardsExecute executes the request
	//  @return []WireGuard
	ListDeviceWireGuardsExecute(r ApiListDeviceWireGuardsRequest) ([]WireGuard, *http.Response, error)

	/*
	ListDevices Device List

	Retrieve devices list


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDevicesRequest
	*/
	ListDevices(ctx context.Context) ApiListDevicesRequest

	// ListDevicesExecute executes the request
	//  @return []Device
	ListDevicesExecute(r ApiListDevicesRequest) ([]Device, *http.Response, error)

	/*
	UpdateDevice Update device properties

	Update device properties


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@return ApiUpdateDeviceRequest
	*/
	UpdateDevice(ctx context.Context, deviceID string) ApiUpdateDeviceRequest

	// UpdateDeviceExecute executes the request
	//  @return Device
	UpdateDeviceExecute(r ApiUpdateDeviceRequest) (*Device, *http.Response, error)

	/*
	UpdateDevicePortForwarding Update device's port forwarding

	Update device's port forwarding dst_port


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceID
	@param portForwardingID
	@return ApiUpdateDevicePortForwardingRequest
	*/
	UpdateDevicePortForwarding(ctx context.Context, deviceID string, portForwardingID string) ApiUpdateDevicePortForwardingRequest

	// UpdateDevicePortForwardingExecute executes the request
	//  @return PortForwarding
	UpdateDevicePortForwardingExecute(r ApiUpdateDevicePortForwardingRequest) (*PortForwarding, *http.Response, error)
}

// DeviceApiService DeviceApi service
type DeviceApiService service

type ApiCreateDeviceRequest struct {
	ctx context.Context
	ApiService DeviceApi
	createOrUpdateDeviceRequest *CreateOrUpdateDeviceRequest
}

func (r ApiCreateDeviceRequest) CreateOrUpdateDeviceRequest(createOrUpdateDeviceRequest CreateOrUpdateDeviceRequest) ApiCreateDeviceRequest {
	r.createOrUpdateDeviceRequest = &createOrUpdateDeviceRequest
	return r
}

func (r ApiCreateDeviceRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.CreateDeviceExecute(r)
}

/*
CreateDevice Create new device

Create new device


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDeviceRequest
*/
func (a *DeviceApiService) CreateDevice(ctx context.Context) ApiCreateDeviceRequest {
	return ApiCreateDeviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Device
func (a *DeviceApiService) CreateDeviceExecute(r ApiCreateDeviceRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.CreateDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateDeviceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDevicePortForwardingRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	createOrUpdatePortForwardingRequest *CreateOrUpdatePortForwardingRequest
}

func (r ApiCreateDevicePortForwardingRequest) CreateOrUpdatePortForwardingRequest(createOrUpdatePortForwardingRequest CreateOrUpdatePortForwardingRequest) ApiCreateDevicePortForwardingRequest {
	r.createOrUpdatePortForwardingRequest = &createOrUpdatePortForwardingRequest
	return r
}

func (r ApiCreateDevicePortForwardingRequest) Execute() (*PortForwarding, *http.Response, error) {
	return r.ApiService.CreateDevicePortForwardingExecute(r)
}

/*
CreateDevicePortForwarding Create new device port forwarding

Create new device port forwarding


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiCreateDevicePortForwardingRequest
*/
func (a *DeviceApiService) CreateDevicePortForwarding(ctx context.Context, deviceID string) ApiCreateDevicePortForwardingRequest {
	return ApiCreateDevicePortForwardingRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
//  @return PortForwarding
func (a *DeviceApiService) CreateDevicePortForwardingExecute(r ApiCreateDevicePortForwardingRequest) (*PortForwarding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PortForwarding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.CreateDevicePortForwarding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/port-forwarding/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdatePortForwardingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDeviceRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
}

func (r ApiDeleteDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDeviceExecute(r)
}

/*
DeleteDevice Delete Device

Delete device by id


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiDeleteDeviceRequest
*/
func (a *DeviceApiService) DeleteDevice(ctx context.Context, deviceID string) ApiDeleteDeviceRequest {
	return ApiDeleteDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
func (a *DeviceApiService) DeleteDeviceExecute(r ApiDeleteDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.DeleteDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDevicePortForwardingRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	portForwardingID string
}

func (r ApiDeleteDevicePortForwardingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDevicePortForwardingExecute(r)
}

/*
DeleteDevicePortForwarding Delete Device's Port Forwarding

Delete device's port forwarding by id


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @param portForwardingID
 @return ApiDeleteDevicePortForwardingRequest
*/
func (a *DeviceApiService) DeleteDevicePortForwarding(ctx context.Context, deviceID string, portForwardingID string) ApiDeleteDevicePortForwardingRequest {
	return ApiDeleteDevicePortForwardingRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
		portForwardingID: portForwardingID,
	}
}

// Execute executes the request
func (a *DeviceApiService) DeleteDevicePortForwardingExecute(r ApiDeleteDevicePortForwardingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.DeleteDevicePortForwarding")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/port-forwarding/{portForwardingID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"portForwardingID"+"}", url.PathEscape(parameterToString(r.portForwardingID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeviceRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
}

func (r ApiGetDeviceRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.GetDeviceExecute(r)
}

/*
GetDevice Device Info

Retrieve device info


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiGetDeviceRequest
*/
func (a *DeviceApiService) GetDevice(ctx context.Context, deviceID string) ApiGetDeviceRequest {
	return ApiGetDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
//  @return Device
func (a *DeviceApiService) GetDeviceExecute(r ApiGetDeviceRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.GetDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceStatsRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	statsID string
}

func (r ApiGetDeviceStatsRequest) Execute() (*DeviceStats, *http.Response, error) {
	return r.ApiService.GetDeviceStatsExecute(r)
}

/*
GetDeviceStats Device's stats detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @param statsID
 @return ApiGetDeviceStatsRequest
*/
func (a *DeviceApiService) GetDeviceStats(ctx context.Context, deviceID string, statsID string) ApiGetDeviceStatsRequest {
	return ApiGetDeviceStatsRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
		statsID: statsID,
	}
}

// Execute executes the request
//  @return DeviceStats
func (a *DeviceApiService) GetDeviceStatsExecute(r ApiGetDeviceStatsRequest) (*DeviceStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.GetDeviceStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/stats/{statsID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statsID"+"}", url.PathEscape(parameterToString(r.statsID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceWireGuardRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	wireGuardID string
}

func (r ApiGetDeviceWireGuardRequest) Execute() (*WireGuard, *http.Response, error) {
	return r.ApiService.GetDeviceWireGuardExecute(r)
}

/*
GetDeviceWireGuard Device's wireguard profile detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @param wireGuardID
 @return ApiGetDeviceWireGuardRequest
*/
func (a *DeviceApiService) GetDeviceWireGuard(ctx context.Context, deviceID string, wireGuardID string) ApiGetDeviceWireGuardRequest {
	return ApiGetDeviceWireGuardRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
		wireGuardID: wireGuardID,
	}
}

// Execute executes the request
//  @return WireGuard
func (a *DeviceApiService) GetDeviceWireGuardExecute(r ApiGetDeviceWireGuardRequest) (*WireGuard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WireGuard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.GetDeviceWireGuard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/wireguards/{wireGuardID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wireGuardID"+"}", url.PathEscape(parameterToString(r.wireGuardID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeviceBindingsRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
}

func (r ApiListDeviceBindingsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ListDeviceBindingsExecute(r)
}

/*
ListDeviceBindings Device bindings

Each device has bindings to specific servers. This methods returns hostnames where this device binded
in a particular time.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiListDeviceBindingsRequest
*/
func (a *DeviceApiService) ListDeviceBindings(ctx context.Context, deviceID string) ApiListDeviceBindingsRequest {
	return ApiListDeviceBindingsRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
//  @return []string
func (a *DeviceApiService) ListDeviceBindingsExecute(r ApiListDeviceBindingsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.ListDeviceBindings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/bindings/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeviceConnectionModesRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	xAndroidPackage *string
	xAndroidSHA1 *string
}

func (r ApiListDeviceConnectionModesRequest) XAndroidPackage(xAndroidPackage string) ApiListDeviceConnectionModesRequest {
	r.xAndroidPackage = &xAndroidPackage
	return r
}

func (r ApiListDeviceConnectionModesRequest) XAndroidSHA1(xAndroidSHA1 string) ApiListDeviceConnectionModesRequest {
	r.xAndroidSHA1 = &xAndroidSHA1
	return r
}

func (r ApiListDeviceConnectionModesRequest) Execute() ([]ConnectionMode, *http.Response, error) {
	return r.ApiService.ListDeviceConnectionModesExecute(r)
}

/*
ListDeviceConnectionModes Device connection modes

This methods returns list of connection modes are availbale for current device.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiListDeviceConnectionModesRequest
*/
func (a *DeviceApiService) ListDeviceConnectionModes(ctx context.Context, deviceID string) ApiListDeviceConnectionModesRequest {
	return ApiListDeviceConnectionModesRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
//  @return []ConnectionMode
func (a *DeviceApiService) ListDeviceConnectionModesExecute(r ApiListDeviceConnectionModesRequest) ([]ConnectionMode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConnectionMode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.ListDeviceConnectionModes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/connection-modes/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAndroidPackage != nil {
		localVarHeaderParams["X-Android-Package"] = parameterToString(*r.xAndroidPackage, "")
	}
	if r.xAndroidSHA1 != nil {
		localVarHeaderParams["X-Android-SHA1"] = parameterToString(*r.xAndroidSHA1, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeviceDetailStatsRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	dateTimeAfter *string
	dateTimeBefore *string
	perPage *float32
	page *float32
}

func (r ApiListDeviceDetailStatsRequest) DateTimeAfter(dateTimeAfter string) ApiListDeviceDetailStatsRequest {
	r.dateTimeAfter = &dateTimeAfter
	return r
}

func (r ApiListDeviceDetailStatsRequest) DateTimeBefore(dateTimeBefore string) ApiListDeviceDetailStatsRequest {
	r.dateTimeBefore = &dateTimeBefore
	return r
}

func (r ApiListDeviceDetailStatsRequest) PerPage(perPage float32) ApiListDeviceDetailStatsRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListDeviceDetailStatsRequest) Page(page float32) ApiListDeviceDetailStatsRequest {
	r.page = &page
	return r
}

func (r ApiListDeviceDetailStatsRequest) Execute() ([]DeviceStats, *http.Response, error) {
	return r.ApiService.ListDeviceDetailStatsExecute(r)
}

/*
ListDeviceDetailStats Device's detail stats list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiListDeviceDetailStatsRequest
*/
func (a *DeviceApiService) ListDeviceDetailStats(ctx context.Context, deviceID string) ApiListDeviceDetailStatsRequest {
	return ApiListDeviceDetailStatsRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
//  @return []DeviceStats
func (a *DeviceApiService) ListDeviceDetailStatsExecute(r ApiListDeviceDetailStatsRequest) ([]DeviceStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.ListDeviceDetailStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/detail-stats/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateTimeAfter != nil {
		localVarQueryParams.Add("date_time_after", parameterToString(*r.dateTimeAfter, ""))
	}
	if r.dateTimeBefore != nil {
		localVarQueryParams.Add("date_time_before", parameterToString(*r.dateTimeBefore, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDevicePortForwardingsRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	perPage *float32
	page *float32
}

func (r ApiListDevicePortForwardingsRequest) PerPage(perPage float32) ApiListDevicePortForwardingsRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListDevicePortForwardingsRequest) Page(page float32) ApiListDevicePortForwardingsRequest {
	r.page = &page
	return r
}

func (r ApiListDevicePortForwardingsRequest) Execute() ([]PortForwarding, *http.Response, error) {
	return r.ApiService.ListDevicePortForwardingsExecute(r)
}

/*
ListDevicePortForwardings Device Port Forwarding List

Retrieve device's port forwarding lis


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiListDevicePortForwardingsRequest
*/
func (a *DeviceApiService) ListDevicePortForwardings(ctx context.Context, deviceID string) ApiListDevicePortForwardingsRequest {
	return ApiListDevicePortForwardingsRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
//  @return []PortForwarding
func (a *DeviceApiService) ListDevicePortForwardingsExecute(r ApiListDevicePortForwardingsRequest) ([]PortForwarding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PortForwarding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.ListDevicePortForwardings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/port-forwarding/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeviceStatsRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	dateAfter *string
	dateBefore *string
	perPage *float32
	page *float32
}

func (r ApiListDeviceStatsRequest) DateAfter(dateAfter string) ApiListDeviceStatsRequest {
	r.dateAfter = &dateAfter
	return r
}

func (r ApiListDeviceStatsRequest) DateBefore(dateBefore string) ApiListDeviceStatsRequest {
	r.dateBefore = &dateBefore
	return r
}

func (r ApiListDeviceStatsRequest) PerPage(perPage float32) ApiListDeviceStatsRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListDeviceStatsRequest) Page(page float32) ApiListDeviceStatsRequest {
	r.page = &page
	return r
}

func (r ApiListDeviceStatsRequest) Execute() ([]DeviceStats, *http.Response, error) {
	return r.ApiService.ListDeviceStatsExecute(r)
}

/*
ListDeviceStats Device's stats list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiListDeviceStatsRequest
*/
func (a *DeviceApiService) ListDeviceStats(ctx context.Context, deviceID string) ApiListDeviceStatsRequest {
	return ApiListDeviceStatsRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
//  @return []DeviceStats
func (a *DeviceApiService) ListDeviceStatsExecute(r ApiListDeviceStatsRequest) ([]DeviceStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeviceStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.ListDeviceStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/stats/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateAfter != nil {
		localVarQueryParams.Add("date_after", parameterToString(*r.dateAfter, ""))
	}
	if r.dateBefore != nil {
		localVarQueryParams.Add("date_before", parameterToString(*r.dateBefore, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeviceWireGuardPeersRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	wireGuardID string
}

func (r ApiListDeviceWireGuardPeersRequest) Execute() ([]WireGuardPeer, *http.Response, error) {
	return r.ApiService.ListDeviceWireGuardPeersExecute(r)
}

/*
ListDeviceWireGuardPeers Device's wireguard peers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @param wireGuardID
 @return ApiListDeviceWireGuardPeersRequest
*/
func (a *DeviceApiService) ListDeviceWireGuardPeers(ctx context.Context, deviceID string, wireGuardID string) ApiListDeviceWireGuardPeersRequest {
	return ApiListDeviceWireGuardPeersRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
		wireGuardID: wireGuardID,
	}
}

// Execute executes the request
//  @return []WireGuardPeer
func (a *DeviceApiService) ListDeviceWireGuardPeersExecute(r ApiListDeviceWireGuardPeersRequest) ([]WireGuardPeer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WireGuardPeer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.ListDeviceWireGuardPeers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/wireguards/{wireGuardID}/peers/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wireGuardID"+"}", url.PathEscape(parameterToString(r.wireGuardID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeviceWireGuardsRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	perPage *float32
	page *float32
}

func (r ApiListDeviceWireGuardsRequest) PerPage(perPage float32) ApiListDeviceWireGuardsRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListDeviceWireGuardsRequest) Page(page float32) ApiListDeviceWireGuardsRequest {
	r.page = &page
	return r
}

func (r ApiListDeviceWireGuardsRequest) Execute() ([]WireGuard, *http.Response, error) {
	return r.ApiService.ListDeviceWireGuardsExecute(r)
}

/*
ListDeviceWireGuards Device's wireguard profiles list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiListDeviceWireGuardsRequest
*/
func (a *DeviceApiService) ListDeviceWireGuards(ctx context.Context, deviceID string) ApiListDeviceWireGuardsRequest {
	return ApiListDeviceWireGuardsRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
//  @return []WireGuard
func (a *DeviceApiService) ListDeviceWireGuardsExecute(r ApiListDeviceWireGuardsRequest) ([]WireGuard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WireGuard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.ListDeviceWireGuards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/wireguards/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDevicesRequest struct {
	ctx context.Context
	ApiService DeviceApi
	externalKey *string
	perPage *float32
	page *float32
}

func (r ApiListDevicesRequest) ExternalKey(externalKey string) ApiListDevicesRequest {
	r.externalKey = &externalKey
	return r
}

func (r ApiListDevicesRequest) PerPage(perPage float32) ApiListDevicesRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListDevicesRequest) Page(page float32) ApiListDevicesRequest {
	r.page = &page
	return r
}

func (r ApiListDevicesRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.ListDevicesExecute(r)
}

/*
ListDevices Device List

Retrieve devices list


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDevicesRequest
*/
func (a *DeviceApiService) ListDevices(ctx context.Context) ApiListDevicesRequest {
	return ApiListDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Device
func (a *DeviceApiService) ListDevicesExecute(r ApiListDevicesRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.ListDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.externalKey != nil {
		localVarQueryParams.Add("external_key", parameterToString(*r.externalKey, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDeviceRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	createOrUpdateDeviceRequest *CreateOrUpdateDeviceRequest
}

func (r ApiUpdateDeviceRequest) CreateOrUpdateDeviceRequest(createOrUpdateDeviceRequest CreateOrUpdateDeviceRequest) ApiUpdateDeviceRequest {
	r.createOrUpdateDeviceRequest = &createOrUpdateDeviceRequest
	return r
}

func (r ApiUpdateDeviceRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.UpdateDeviceExecute(r)
}

/*
UpdateDevice Update device properties

Update device properties


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @return ApiUpdateDeviceRequest
*/
func (a *DeviceApiService) UpdateDevice(ctx context.Context, deviceID string) ApiUpdateDeviceRequest {
	return ApiUpdateDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
	}
}

// Execute executes the request
//  @return Device
func (a *DeviceApiService) UpdateDeviceExecute(r ApiUpdateDeviceRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.UpdateDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdateDeviceRequest == nil {
		return localVarReturnValue, nil, reportError("createOrUpdateDeviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateDeviceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDevicePortForwardingRequest struct {
	ctx context.Context
	ApiService DeviceApi
	deviceID string
	portForwardingID string
	createOrUpdatePortForwardingRequest *CreateOrUpdatePortForwardingRequest
}

func (r ApiUpdateDevicePortForwardingRequest) CreateOrUpdatePortForwardingRequest(createOrUpdatePortForwardingRequest CreateOrUpdatePortForwardingRequest) ApiUpdateDevicePortForwardingRequest {
	r.createOrUpdatePortForwardingRequest = &createOrUpdatePortForwardingRequest
	return r
}

func (r ApiUpdateDevicePortForwardingRequest) Execute() (*PortForwarding, *http.Response, error) {
	return r.ApiService.UpdateDevicePortForwardingExecute(r)
}

/*
UpdateDevicePortForwarding Update device's port forwarding

Update device's port forwarding dst_port


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceID
 @param portForwardingID
 @return ApiUpdateDevicePortForwardingRequest
*/
func (a *DeviceApiService) UpdateDevicePortForwarding(ctx context.Context, deviceID string, portForwardingID string) ApiUpdateDevicePortForwardingRequest {
	return ApiUpdateDevicePortForwardingRequest{
		ApiService: a,
		ctx: ctx,
		deviceID: deviceID,
		portForwardingID: portForwardingID,
	}
}

// Execute executes the request
//  @return PortForwarding
func (a *DeviceApiService) UpdateDevicePortForwardingExecute(r ApiUpdateDevicePortForwardingRequest) (*PortForwarding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PortForwarding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceApiService.UpdateDevicePortForwarding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{deviceID}/port-forwarding/{portForwardingID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceID"+"}", url.PathEscape(parameterToString(r.deviceID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"portForwardingID"+"}", url.PathEscape(parameterToString(r.portForwardingID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdatePortForwardingRequest == nil {
		return localVarReturnValue, nil, reportError("createOrUpdatePortForwardingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdatePortForwardingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
