/*
ForestVPN API

ForestVPN - Fast, secure, and modern VPN. It offers Distributed Computing, Crypto Mining, P2P, Ad Blocking, TOR over VPN, 30+ locations, and a free version with unlimited data. 

API version: 2.0
Contact: support@forestvpn.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package forestvpn_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type CheckoutApi interface {

	/*
	ApplyCouponCheckoutSession Apply coupon to session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionID
	@return ApiApplyCouponCheckoutSessionRequest
	*/
	ApplyCouponCheckoutSession(ctx context.Context, sessionID string) ApiApplyCouponCheckoutSessionRequest

	// ApplyCouponCheckoutSessionExecute executes the request
	//  @return CouponCheckoutSession
	ApplyCouponCheckoutSessionExecute(r ApiApplyCouponCheckoutSessionRequest) (*CouponCheckoutSession, *http.Response, error)

	/*
	CreateCheckoutSession Create checkout session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateCheckoutSessionRequest
	*/
	CreateCheckoutSession(ctx context.Context) ApiCreateCheckoutSessionRequest

	// CreateCheckoutSessionExecute executes the request
	//  @return CheckoutSession
	CreateCheckoutSessionExecute(r ApiCreateCheckoutSessionRequest) (*CheckoutSession, *http.Response, error)

	/*
	CreateWaitListRequest Create request to add country in wait list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateWaitListRequestRequest
	*/
	CreateWaitListRequest(ctx context.Context) ApiCreateWaitListRequestRequest

	// CreateWaitListRequestExecute executes the request
	CreateWaitListRequestExecute(r ApiCreateWaitListRequestRequest) (*http.Response, error)

	/*
	ExpireCheckoutSession Expire checkout session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionID
	@return ApiExpireCheckoutSessionRequest
	*/
	ExpireCheckoutSession(ctx context.Context, sessionID string) ApiExpireCheckoutSessionRequest

	// ExpireCheckoutSessionExecute executes the request
	ExpireCheckoutSessionExecute(r ApiExpireCheckoutSessionRequest) (*http.Response, error)

	/*
	GetCheckoutSession Checkout session details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionID
	@return ApiGetCheckoutSessionRequest
	*/
	GetCheckoutSession(ctx context.Context, sessionID string) ApiGetCheckoutSessionRequest

	// GetCheckoutSessionExecute executes the request
	//  @return CheckoutSession
	GetCheckoutSessionExecute(r ApiGetCheckoutSessionRequest) (*CheckoutSession, *http.Response, error)

	/*
	GetStripeCheckoutSession Stripe checkout session details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionID
	@return ApiGetStripeCheckoutSessionRequest
	*/
	GetStripeCheckoutSession(ctx context.Context, sessionID string) ApiGetStripeCheckoutSessionRequest

	// GetStripeCheckoutSessionExecute executes the request
	//  @return StripeCheckoutSession
	GetStripeCheckoutSessionExecute(r ApiGetStripeCheckoutSessionRequest) (*StripeCheckoutSession, *http.Response, error)

	/*
	GetStripePaymentIntent Stripe payment intent details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionID
	@return ApiGetStripePaymentIntentRequest
	*/
	GetStripePaymentIntent(ctx context.Context, sessionID string) ApiGetStripePaymentIntentRequest

	// GetStripePaymentIntentExecute executes the request
	//  @return StripePaymentIntent
	GetStripePaymentIntentExecute(r ApiGetStripePaymentIntentRequest) (*StripePaymentIntent, *http.Response, error)

	/*
	ProcessCloudPaymentsAuth Cloud payments auth

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionID
	@return ApiProcessCloudPaymentsAuthRequest
	*/
	ProcessCloudPaymentsAuth(ctx context.Context, sessionID string) ApiProcessCloudPaymentsAuthRequest

	// ProcessCloudPaymentsAuthExecute executes the request
	//  @return CloudPaymentsAuth
	ProcessCloudPaymentsAuthExecute(r ApiProcessCloudPaymentsAuthRequest) (*CloudPaymentsAuth, *http.Response, error)

	/*
	ProcessCloudPaymentsPost3ds Cloud payments post3ds

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionID
	@return ApiProcessCloudPaymentsPost3dsRequest
	*/
	ProcessCloudPaymentsPost3ds(ctx context.Context, sessionID string) ApiProcessCloudPaymentsPost3dsRequest

	// ProcessCloudPaymentsPost3dsExecute executes the request
	//  @return CloudPaymentsPost3ds
	ProcessCloudPaymentsPost3dsExecute(r ApiProcessCloudPaymentsPost3dsRequest) (*CloudPaymentsPost3ds, *http.Response, error)
}

// CheckoutApiService CheckoutApi service
type CheckoutApiService service

type ApiApplyCouponCheckoutSessionRequest struct {
	ctx context.Context
	ApiService CheckoutApi
	sessionID string
	createCouponCheckoutSession *CreateCouponCheckoutSession
}

func (r ApiApplyCouponCheckoutSessionRequest) CreateCouponCheckoutSession(createCouponCheckoutSession CreateCouponCheckoutSession) ApiApplyCouponCheckoutSessionRequest {
	r.createCouponCheckoutSession = &createCouponCheckoutSession
	return r
}

func (r ApiApplyCouponCheckoutSessionRequest) Execute() (*CouponCheckoutSession, *http.Response, error) {
	return r.ApiService.ApplyCouponCheckoutSessionExecute(r)
}

/*
ApplyCouponCheckoutSession Apply coupon to session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionID
 @return ApiApplyCouponCheckoutSessionRequest
*/
func (a *CheckoutApiService) ApplyCouponCheckoutSession(ctx context.Context, sessionID string) ApiApplyCouponCheckoutSessionRequest {
	return ApiApplyCouponCheckoutSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionID: sessionID,
	}
}

// Execute executes the request
//  @return CouponCheckoutSession
func (a *CheckoutApiService) ApplyCouponCheckoutSessionExecute(r ApiApplyCouponCheckoutSessionRequest) (*CouponCheckoutSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CouponCheckoutSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CheckoutApiService.ApplyCouponCheckoutSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/checkout/sessions/{sessionID}/apply_coupon/"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionID"+"}", url.PathEscape(parameterToString(r.sessionID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCouponCheckoutSession == nil {
		return localVarReturnValue, nil, reportError("createCouponCheckoutSession is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCouponCheckoutSession
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCheckoutSessionRequest struct {
	ctx context.Context
	ApiService CheckoutApi
	createCheckoutSessionRequest *CreateCheckoutSessionRequest
}

func (r ApiCreateCheckoutSessionRequest) CreateCheckoutSessionRequest(createCheckoutSessionRequest CreateCheckoutSessionRequest) ApiCreateCheckoutSessionRequest {
	r.createCheckoutSessionRequest = &createCheckoutSessionRequest
	return r
}

func (r ApiCreateCheckoutSessionRequest) Execute() (*CheckoutSession, *http.Response, error) {
	return r.ApiService.CreateCheckoutSessionExecute(r)
}

/*
CreateCheckoutSession Create checkout session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCheckoutSessionRequest
*/
func (a *CheckoutApiService) CreateCheckoutSession(ctx context.Context) ApiCreateCheckoutSessionRequest {
	return ApiCreateCheckoutSessionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckoutSession
func (a *CheckoutApiService) CreateCheckoutSessionExecute(r ApiCreateCheckoutSessionRequest) (*CheckoutSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckoutSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CheckoutApiService.CreateCheckoutSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/checkout/sessions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCheckoutSessionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWaitListRequestRequest struct {
	ctx context.Context
	ApiService CheckoutApi
	xCountry *string
}

func (r ApiCreateWaitListRequestRequest) XCountry(xCountry string) ApiCreateWaitListRequestRequest {
	r.xCountry = &xCountry
	return r
}

func (r ApiCreateWaitListRequestRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateWaitListRequestExecute(r)
}

/*
CreateWaitListRequest Create request to add country in wait list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWaitListRequestRequest
*/
func (a *CheckoutApiService) CreateWaitListRequest(ctx context.Context) ApiCreateWaitListRequestRequest {
	return ApiCreateWaitListRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CheckoutApiService) CreateWaitListRequestExecute(r ApiCreateWaitListRequestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CheckoutApiService.CreateWaitListRequest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/checkout/wait-list/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xCountry != nil {
		localVarHeaderParams["X-Country"] = parameterToString(*r.xCountry, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExpireCheckoutSessionRequest struct {
	ctx context.Context
	ApiService CheckoutApi
	sessionID string
}

func (r ApiExpireCheckoutSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExpireCheckoutSessionExecute(r)
}

/*
ExpireCheckoutSession Expire checkout session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionID
 @return ApiExpireCheckoutSessionRequest
*/
func (a *CheckoutApiService) ExpireCheckoutSession(ctx context.Context, sessionID string) ApiExpireCheckoutSessionRequest {
	return ApiExpireCheckoutSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionID: sessionID,
	}
}

// Execute executes the request
func (a *CheckoutApiService) ExpireCheckoutSessionExecute(r ApiExpireCheckoutSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CheckoutApiService.ExpireCheckoutSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/checkout/sessions/{sessionID}/expire/"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionID"+"}", url.PathEscape(parameterToString(r.sessionID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCheckoutSessionRequest struct {
	ctx context.Context
	ApiService CheckoutApi
	sessionID string
}

func (r ApiGetCheckoutSessionRequest) Execute() (*CheckoutSession, *http.Response, error) {
	return r.ApiService.GetCheckoutSessionExecute(r)
}

/*
GetCheckoutSession Checkout session details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionID
 @return ApiGetCheckoutSessionRequest
*/
func (a *CheckoutApiService) GetCheckoutSession(ctx context.Context, sessionID string) ApiGetCheckoutSessionRequest {
	return ApiGetCheckoutSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionID: sessionID,
	}
}

// Execute executes the request
//  @return CheckoutSession
func (a *CheckoutApiService) GetCheckoutSessionExecute(r ApiGetCheckoutSessionRequest) (*CheckoutSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckoutSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CheckoutApiService.GetCheckoutSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/checkout/sessions/{sessionID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionID"+"}", url.PathEscape(parameterToString(r.sessionID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStripeCheckoutSessionRequest struct {
	ctx context.Context
	ApiService CheckoutApi
	sessionID string
}

func (r ApiGetStripeCheckoutSessionRequest) Execute() (*StripeCheckoutSession, *http.Response, error) {
	return r.ApiService.GetStripeCheckoutSessionExecute(r)
}

/*
GetStripeCheckoutSession Stripe checkout session details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionID
 @return ApiGetStripeCheckoutSessionRequest
*/
func (a *CheckoutApiService) GetStripeCheckoutSession(ctx context.Context, sessionID string) ApiGetStripeCheckoutSessionRequest {
	return ApiGetStripeCheckoutSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionID: sessionID,
	}
}

// Execute executes the request
//  @return StripeCheckoutSession
func (a *CheckoutApiService) GetStripeCheckoutSessionExecute(r ApiGetStripeCheckoutSessionRequest) (*StripeCheckoutSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StripeCheckoutSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CheckoutApiService.GetStripeCheckoutSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/checkout/sessions/{sessionID}/stripe/checkout/session/"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionID"+"}", url.PathEscape(parameterToString(r.sessionID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStripePaymentIntentRequest struct {
	ctx context.Context
	ApiService CheckoutApi
	sessionID string
	useStripeSdk *bool
	returnUrl *string
}

func (r ApiGetStripePaymentIntentRequest) UseStripeSdk(useStripeSdk bool) ApiGetStripePaymentIntentRequest {
	r.useStripeSdk = &useStripeSdk
	return r
}

func (r ApiGetStripePaymentIntentRequest) ReturnUrl(returnUrl string) ApiGetStripePaymentIntentRequest {
	r.returnUrl = &returnUrl
	return r
}

func (r ApiGetStripePaymentIntentRequest) Execute() (*StripePaymentIntent, *http.Response, error) {
	return r.ApiService.GetStripePaymentIntentExecute(r)
}

/*
GetStripePaymentIntent Stripe payment intent details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionID
 @return ApiGetStripePaymentIntentRequest
*/
func (a *CheckoutApiService) GetStripePaymentIntent(ctx context.Context, sessionID string) ApiGetStripePaymentIntentRequest {
	return ApiGetStripePaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
		sessionID: sessionID,
	}
}

// Execute executes the request
//  @return StripePaymentIntent
func (a *CheckoutApiService) GetStripePaymentIntentExecute(r ApiGetStripePaymentIntentRequest) (*StripePaymentIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StripePaymentIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CheckoutApiService.GetStripePaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/checkout/sessions/{sessionID}/stripe/payment/intent/"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionID"+"}", url.PathEscape(parameterToString(r.sessionID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useStripeSdk != nil {
		localVarQueryParams.Add("use_stripe_sdk", parameterToString(*r.useStripeSdk, ""))
	}
	if r.returnUrl != nil {
		localVarQueryParams.Add("return_url", parameterToString(*r.returnUrl, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProcessCloudPaymentsAuthRequest struct {
	ctx context.Context
	ApiService CheckoutApi
	sessionID string
	createCloudPaymentsAuth *CreateCloudPaymentsAuth
}

func (r ApiProcessCloudPaymentsAuthRequest) CreateCloudPaymentsAuth(createCloudPaymentsAuth CreateCloudPaymentsAuth) ApiProcessCloudPaymentsAuthRequest {
	r.createCloudPaymentsAuth = &createCloudPaymentsAuth
	return r
}

func (r ApiProcessCloudPaymentsAuthRequest) Execute() (*CloudPaymentsAuth, *http.Response, error) {
	return r.ApiService.ProcessCloudPaymentsAuthExecute(r)
}

/*
ProcessCloudPaymentsAuth Cloud payments auth

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionID
 @return ApiProcessCloudPaymentsAuthRequest
*/
func (a *CheckoutApiService) ProcessCloudPaymentsAuth(ctx context.Context, sessionID string) ApiProcessCloudPaymentsAuthRequest {
	return ApiProcessCloudPaymentsAuthRequest{
		ApiService: a,
		ctx: ctx,
		sessionID: sessionID,
	}
}

// Execute executes the request
//  @return CloudPaymentsAuth
func (a *CheckoutApiService) ProcessCloudPaymentsAuthExecute(r ApiProcessCloudPaymentsAuthRequest) (*CloudPaymentsAuth, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CloudPaymentsAuth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CheckoutApiService.ProcessCloudPaymentsAuth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/checkout/sessions/{sessionID}/cloud-payments/auth/"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionID"+"}", url.PathEscape(parameterToString(r.sessionID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCloudPaymentsAuth == nil {
		return localVarReturnValue, nil, reportError("createCloudPaymentsAuth is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCloudPaymentsAuth
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProcessCloudPaymentsPost3dsRequest struct {
	ctx context.Context
	ApiService CheckoutApi
	sessionID string
	createCloudPaymentsPost3ds *CreateCloudPaymentsPost3ds
}

func (r ApiProcessCloudPaymentsPost3dsRequest) CreateCloudPaymentsPost3ds(createCloudPaymentsPost3ds CreateCloudPaymentsPost3ds) ApiProcessCloudPaymentsPost3dsRequest {
	r.createCloudPaymentsPost3ds = &createCloudPaymentsPost3ds
	return r
}

func (r ApiProcessCloudPaymentsPost3dsRequest) Execute() (*CloudPaymentsPost3ds, *http.Response, error) {
	return r.ApiService.ProcessCloudPaymentsPost3dsExecute(r)
}

/*
ProcessCloudPaymentsPost3ds Cloud payments post3ds

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionID
 @return ApiProcessCloudPaymentsPost3dsRequest
*/
func (a *CheckoutApiService) ProcessCloudPaymentsPost3ds(ctx context.Context, sessionID string) ApiProcessCloudPaymentsPost3dsRequest {
	return ApiProcessCloudPaymentsPost3dsRequest{
		ApiService: a,
		ctx: ctx,
		sessionID: sessionID,
	}
}

// Execute executes the request
//  @return CloudPaymentsPost3ds
func (a *CheckoutApiService) ProcessCloudPaymentsPost3dsExecute(r ApiProcessCloudPaymentsPost3dsRequest) (*CloudPaymentsPost3ds, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CloudPaymentsPost3ds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CheckoutApiService.ProcessCloudPaymentsPost3ds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/checkout/sessions/{sessionID}/cloud-payments/post3ds/"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionID"+"}", url.PathEscape(parameterToString(r.sessionID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCloudPaymentsPost3ds == nil {
		return localVarReturnValue, nil, reportError("createCloudPaymentsPost3ds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCloudPaymentsPost3ds
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
